# 중요하지만 헷갈리는 리액트 개념 이해하기
## 상탯값과 속성값으로 관리하는 UI 데이터
UI 라이브러리인 리액트는 UI 데이터를 관리하는 방법으로 제공한다.<br>
UI 데이터는 컴포넌트 내부에서 관리되는 상탯값과 부모 컴포넌트에서 내려주는 속성값으로 구성된다<br>
리덕스와 같이 전역 데이터를 관리해 주는 라이브러리를 리액트에 적용할 때도 결국에는 컴포넌트의 상탯값과 속성값을 이용해서 구현한다.<br><br>
UI 데이터가 변경되면 화면을 다시 그려야하는데 리액트와 같은 UI 라이브러리를 사용하지 않는다면 UI 데이터가 변경될 때 마다 돔 요소를 직접 추가해야한다.<br>
돔 요소를 직접 수정하다 보면 비즈니스 로직과 UI수정하는 코드가 뒤섞여지고 코드가 복잡해지는데, 리액트는 화면을 그리는 모든 코드를 컴포넌트 함수에 선언형으로 작성하도록 해서
UI 데이터가 변경되면 리액트가 컴포넌트 함수를 이용해서 화면을 자동으로 갱신해 주는 것이 리액트의 가장 중요한 역할이다.
### 리액트를 사용한 코드의 특징
#### UI 라이브러리를 사용하지 않은 코드
```html
<html>
    <body>
        <div class="todo">
            <h3>할 일 목록</h3>
            <ul class="list"></ul>
            <input class="desc" type="text" />
            <button onclick="onAdd()">추가</button>
            <button onclick="onSaveToServer()">서버에 저장</button>
        </div>
        <script>
            let currentId = 1;
            const todoList = []; //todoList 배열에 할 일 목록을 저장
            function onAdd() {
                const inputEl = document.querySelector('.todo .desc');
                const todo = { id: currentId++, desc: descEl.value };
                todoList.push(todo);
                const elemList = document.querySelector('.todo .list');
                const liEl = makeTodoElement(todo);
                elemList.appendChild(liEl);
            }

            function makeTodoElement(todo) {
                const liEl = document.createElement('li');
                const spanEl = document.createElement('span');
                const buttonEl = document.createElement('button');
                spanEl.innerHTML = todo.desc;
                buttonEl.innerHTML = '삭제';
                buttonEl.dataset.id = todo.id;
                buttonEl.onclick = onDelete;
                liEl.appendChild(spanEl);
                liEl.appendChild(buttonEl);
                return liEl;
            }
            function onDelete(e) {
                const id = Number(e.target.dataset.id);
                const index = todoList.findIndex(item => item.id === id);
                if (index >= 0) {
                    todoList.splice(index, 1);
                    const elemList = document.querySelector('.todo .list');
                    const liEl = e.target.parentNode;
                    listEl.removeChild(liEl);
                }
            }

            function onSaveToServer() {
                // todoList 전송
            }
        </script>
    </body>
</html>
```
로직과 UI 코드가 복잡하게 얽혀있어 코드의 가독성이 낮아진다.<br>
명령형 프로그래밍<br>
돔을 직접 수정하면서 화면을 어떻게 그리는지 구체적으로 나타낸다.<br>
구체적이기 때문에 돔 환경 아닌 곳에서는 사용하기 힘들다
#### 리액트로 작성한 코드
```javascript
function MyComponent() {
  const [desc, setDesc] = useState("");
  const [currentId, setCurrentId] = useState(1);
  const [todoList, setTodoList] = useState([]);
  function onAdd() {
    const todo = { id: currentId, desc };
    setCurrentId(currentId + 1);
    setTodoList([...todoList, todo]);
  }
  function onDelete(e) {
    const id = Number(e.target.dataset.id);
    const newTodoList = todoList.filter(todo => todo.id !== id);
    setTodoList(newTodoList);
  }
  function onSaveToServer() {
    //todoList 전송
  }
  return (
    <div>
      <h3>할 일 목록</h3>
      <ul>
        {todoList.map(todo => (
          <li key={todo.id}>
            <span>{todo.desc}</span>
            <button data-id={todo.id} onClick={onDelete}>
              삭제
            </button>
          </li>
        ))}
      </ul>
      <input type="text" value={desc}
              onChange={e => setDesc(e.target.value)} />
      <button onClick={onAdd}>추가</button>
      <button onClick={onSaveToServer}>서버에 저장</button>
    </div>
  )
}
```
UI코드는 할 일을 추가하고 삭제하는 코드와 분리되어 있다.<br>
MyComponent 컴포넌트는 상탯값 todoList, desc를 기반으로 UI를 정의한다.<br>
리액트는 상탯값이 수정되면 컴포넌트 함수를 실행해서 화면을 갱신할 수 있다.<br>
선언형 프로그래밍<br>
무엇을 그리는지만 나타내기 때문에 다양한 방식으로 그릴 수 있다.<br>
컴포넌트 함수가 반환하는 코드는 선언형으로 작성되기 때문에 리액트는 돔 환경뿐만 아니라 모바일 네이티브의 UI도 표현할 수 있다.<br><br>
따라서 선언형 프로그래밍은 명령형 프로그래밍보다 추상화 단계가 높다고 할 수 있다.<br>
추상화 단계가 높을수록 비즈니스 로직에 좀 더 집중할 수 있다는 장점이 있다.
## 컴포넌트의 속성값과 상탯값
### 속성값과 상탯값으로 관리하는 UI 데이터
<u>컴포넌트의 상탯값은 해당 컴포넌트가 관리하는 데이터</u>이고, <u>컴포넌트의 속성값은 부모 컴포넌트로부터 전달받는 데이터</u>이다.<br>
리액트에서 UI데이터는 반드시 상탯값과 속성값으로 관리해야한다.<br>

#### 컴포넌트의 상탯값을 사용하지 않은 코드
```javascript
let color = "red";
function MyComponent() {
  function onClick() {
    color = "blue";
  }
  return (
    <button style={{ backgroundColor: color}} onClick={onClick}> 
      좋아요
    </button>
  );
}
```
버튼을 클릭하면 color 데이터는 파란색으로 변경되지만 화면에 보이는 버튼의 배경색은 여전히 빨간색이다.<br>
이는 리액트 UI 데이터가 변경됐다는 사실을 모르기 때문이다.<br>
#### 컴포넌트의 상탯값을 사용하는 코드
```javascript
import React, { useState } from "react";

function MyComponent() {
  const [color, setColor] = useState("red") //1
  function onClick() {
    setColor("blue"); //2
  }
  return (
    <button style={{ backgroundColor: color}} onClick={onClick}> 
      좋아요
    </button>
  );  
}
```
컴포너트에 상탯값을 추가할 때는 useState훅을 사용한다.<br>
useState훅의 인자는 초깃값을 의미한다. useState가 반환하는 배열의 <u>첫 번째 원소는 상탯값</u>이고, <u>두 번째 원소는 상탯값 변경 함수</u>다.<br>
훅에서는 배열 비구조화 문법을 자주 사용한다.<br>
리액트는 setColor 함수가 호출되면 상탯값을 변경하고 해당 컴포넌트를 다시 렌더링한다.<br>
#### 속성값을 이용한 코드
속성값은 부모 컴포넌트가 전달해 주는 데이터이고, 대부분의 경우 UI 데이터를 포함한다.
```javascript
function Title(props) {
  return <p>{props.title}</p>;
}
```
Title 컴포넌트는 부모 컴포넌트로부터 title이라는 속성값을 받는다. Title 컴포넌트는 부모 컴포넌트가 렌더링될 때 마다 같이 렌더링되므로 title 속성값의 변경 사항이 바로 화면에 반영된다.
#### 부모 컴포넌트에서 속성값을 내려주는 코드
```javascript
function Todo() {
  const [count, setCount] = useState(0);
  function onClick() {
    setCount(count + 1);
  }
  return (
    <div>
      <Title title={`현재 카운트 : ${count}`} /> 
      <button onClick={onClick}>증가</button>
    </div>
  );
}
```
버튼을 클릭할 때마다 count 상탯값을 변경하고 Todo컴포넌트는 다시 렌더링되는데, 이때 Title 컴포넌트는 새로운 title 속성값을 내려받는다.<br>
Title 컴포넌트는 부모 컴포넌트가 렌더링될 때 마다 같이 렌더링된다.
#### React.memo을 사용한 코드
속성값이 변경될 때마다 렌더링이 되길 원한다면 React.memo을 이용할 수 있다.
```javascript
function Title(props) {
  return <p>{props.title}</p>
}
export default React.memo(Title);//1
```
(1) memo 함수의 인수로 컴포넌트를 입력하면, 컴포넌트의 속성값이 변경되는 경우에만 렌더링된다.
#### 사용된 컴포넌트 별로 관리되는 상탯값
```javascript
function App() {
  return (
    <div>
      <MyComponet />
      <MyComponet />
    </div>
  );
}
```
같은 컴포넌트를 여러 번 사용할 수 있는데, 사용된 각 컴포넌트는 상탯값을 위한 자신만의 상탯값이 존재해진다.<br>
그래서 위에 소스를 보면 컴포넌트를 두 번 사용하면 두 개의 상탯값이 따로 관리된다.
### 불변 객체로 관리하는 속성값과 상탯값
속성값은 불변(immutable) 변수이지만 상탯값은 불변 변수가 아니다.<br>
하지만 상탯값도 불변 변수로 관리하는 게 좋다.<br>
#### 속성값 변경을 시도하는 코드
```javascript
function Title(props) {
  props.title = 'abc';
}
```
속성값은 불변 변수이기 때문에 값을 변경하려고 시도하면 에러가 발생한다.<br>
자식 컴포넌트에 전달되는 속성값은 상위 컴포넌트에서 관리하기 때문에 수정하지 못하도록 막혀있다.<br>
그래서 title이라는 데이터를 수정하고 싶다면 title 상탯값을 가진 컴포넌트에서 관리하는 상탯값 변경 함수를 이용해야한다.
#### 상탯값을 직접 수정하는 코드
```javascript
function MyComponent() {
  const [count, setCount] = useState({ value: 0});  
  function onClick() {
    count value = 2; //1
    setCount(count); //2
  }
}
```
(1) 상탯값을 직접할 수는 있지만 화면이 갱신되지 않는다.<br>
(2) 상탯값 변경 함수를 호출해도 화면은 갱신되지 않는다.<br>
리액트는 상탯값 변경 유무를 이전 값과의 단순 비교로 판단하는데, count 객체의 참조값은 그대로이므로 변경 사항이 없다고 판단하고 해당 요청을 무시한다.<br>
따라서 상탯값도 속성값과 같이 불변 변수로 관리하는 게 좋다.<br>
불변 변수로 관리하면 코드의 복잡도가 낮아지는 장점도 있다.
## 컴포넌트 함수의 반환값
#### 컴포넌트 함수가 반환할 수 있는 값
```javascript
return <MyComponent title="안녕하세요" />; //1
return <p>안녕하세요</p>; //1
return '안녕하세요'; //2
return 123; //2
return [<p key="a">안녕하세요</p>, <p key="b">반갑습니다.</p>]; //3
return ( //4
  <React.Fragment>
    <p>안녕하세요</p>
    <p>반갑습니다</p>
  </React.Fragment>
);
return ( //5
  <>
    <p>안녕하세요</p>
    <p>반갑습니다</p>
  </>
);
return null; //6
return false; //6
return ReactDom.createPortal(<p>안녕하세요</p>, domNone); //7
```
- (1) 작성한 컴포넌트와 HTML에 정의된 거의 모든 태그를 사용할 수 있다.<br>
- (2) 문자열과 숫자를 반환할 수 있다.
- (3) 배열을 반환할 수 있다.
- (4) 프래그먼트(fragment)를 사용하면 배열을 사용하지 않고도 여러 개의 요소를 표현할 수 있다. 그리고 key 속성값을 부여하지 않아도 된다.
- (5) 보통은 바벨을 이용해서 프래그먼트를 축약해서 작성한다.
- (6) null 또는 불(boolean)을 반환하면 아무것도 렌더링하지 않는다.
- (7) 리액트 포털(portal)을 사용하면 컴포넌트의 현재 위치와는 상관없이 특정 돔 요소에 랜더링할 수 있다.
#### 컴포넌트 함수에서 조건부 렌더링을 하는 코드
```javascript
function MyComponent({ title }) {
  return title.length > 0 && <p>{title}</p>;
}
```
title 속성값이 길이가 0이면 거짓(false)을 반환하고 결과적으로 아무것도 렌더링되지 않는다.
title 속성값이 길이가 1이면 우측 <p>요소가 반환된다.
#### 리액트 포털을 사용한 코드
```javascript
function Modal({ title, desc }) {
  const domNode = document.getElementById('model');
  return ReactDOM.createPortal(
    <div>
      <p>{title}</p>
      <p>{desc}</p>
    </div>,
    domNode,
  );
}
```
리액트 포털을 이용해서 특정 돔 요소에 리액트 요소를 렌더링할 수 있다.
modal 컴포넌트가 사용된 위치와 상관없이 렌더링할 위치를 선택할 수 있다.
## 리액트 요소와 가상 돔
리액트 요소는 리액트가 UI를 표현하는 수단이다.<br>
보통 우리는 JSX 문법을 사용하기 때문에 리액트 요소의 존재를 잘 모른다.<br>
하지만 리액트 요소를 이해한다면 리액트가 내부적으로 어떻게 동작하는지 알 수 있다<br><br>
리액트는 렌더링 성능을 위해 가상 돔을 활용한다. 브라우저에서 돔을 변경하는 것은 비교적 오래 걸리는 작업이다.<br>
따라서 빠른 렌더링을 위해서는 돔 변경을 최소화한다.<br>
그래서 리액트는 메모리에 가상 돔을 올려 놓고 이전과 이후의 가상 돔을 비교해서 변경된 부분만 실제 돔에 반영하는 전략을 채택했다.<br>
리액트 요소로부터 가상 돔을 만들고, 실제 돔에 반영할 변경 사항을 찾는 과정을 보자.
### 리액트 요소 이해하기
JSX문법으로 작성된 코드는 리액트의 createElement 함수로 변경된다는 사실을 알았다.<br>
createElement 함수는 리액트 요소를 반환하는데, 대부분의 경우 컴포넌트 함수는 리액트 요소를 반환한다ㅏ.<br>
리액트가 UI를 표현하기 위해 사용되는 리액트 요소의 구조를 보자
#### JSX 코드가 createElement 함수를 사용하는 코드로 변경된 예
```javascript
const element = <a href="http://google.com">Click here</a>; //1
const element = React.createElement( //2
  'a',
  { href: 'http://google.com'},
  'click here',
);
```
1번 코드는 2번 코드로 변경된다.
#### 리액트 요소의 구조
```javascript
const element = (
  <a key="key1" style=({ width: 100 }) href="http://google.com">
    click here
  </a>
);
console.log(element);
const consoleLogResult = {
  type: 'a',
  key: 'key1',
  ref: null,
  props: {
    href: 'http://google.com',
    style: {
      width: 100,
    },
    children: 'click here',
  }
};
```
element 변수는 createElement 함수가 반환한 리액트 요소이다. <br>
consoleLogResult는 리액트 요소를 로그로 출력한 결과를 표현한 것이다.<br>
type 속성값이 문자열이면 HTML태그를 나타낸다.<br>
JSX코드에서 key 속성값을 입력하면 리액트 요소의 key속성값으로 들어간다.<br>
JSX코드에서 ref속성값을 입력하면 리액트 요소의 ref속성값으로 들어간다.<br>
key와 ref를 제외한 나머지 속성값은 리액트 요소의 props속성값으로 들어간다.<br>
JSX 코드에서 태그 사이에 표현식이 들어가면, 리액트 요소에는 이 표현식이 여러 개로 분할되어 들어간다.
#### JSX 코드에서 태그 사이에 표현식을 넣은 코드
```javascript
const element = <h1>제 나이는 {20 + 5} 세입니다.</h1>;
console.log(element);
const consoleLogResult = {
  type: 'h1',
  props: {
    children: ['제 나이는, 25, ' 세입니다.'] 
  },
}
```
JSX 코드에서 컴포넌트가 사용되면 리액트 요소의 type 속성값은 해당 컴포넌트 함수가 된다.
#### 컴포넌트가 리액트 요소로 사용된 예
```javascript
function Title({ title, color}) {
  return <p style={{ color }}>{title}</p>
}
const element = <Title title="안녕하세요" color="bule" />
console.log(element);
const consoleLogResult = {
  type: Title,
  props: { title: '안녕하세요', color: 'blue' },
}
```
리액트는 type 속성값으로 전달된 함수를 호출해서 화면을 그리기 위한 충분한 정보를 얻을 수 있다.
#### 리액트 요소는 불변 객체이다.
리액트 요소는 불변 객체이기 때문에 속성값을 변경할 수 없다.
```javascript
const element = 'b'; 
elements.type ='b';
```
리액트는 전달된 리액트 요소를 이전의 리액트 요소와 비교해서 변경된 부분만 실제 돔에 반영한다
#### ReactDOM.render 함수를 주기적으로 호출하는 코드
```javascript
let seconds = 0;
function update() {
  seconds += 1;
  const element = (
    <div>
      <h1>안녕하세요</h1>
      <h2>지금까지 {seconds}초가 지났습니다.</h2>
    </div>
  );
  ReactDOM.render(element, document.getElementById('root'));
}
setInterval(update, 1000);
```
리액트가 새로운 리액트 요소를 받으면 이전의 리액트 요소와 비교해서 변경된 부분만 실제 돔에 반영한다.<br>
따라서 앞의 코드에 의해 업데이트 되는 과정에서 리액트는 실제 돔의 h1요소를 건드리지 않는다.
## 리액트 요소가 돔 요소로 만들어지는 과정
하나의 화면을 표현하기 위해 여러 개의 리액트 요소가 트리 구조로 구성된다.<br>
프로그램 화면은 여러 가지 이벤트를 통해서 다양한 모습으로 변화한다.<br>
리액트에서 데이터 변경에 의한 화면 업데이튼 렌더 단계와 커밋 단계를 거친다.<br>
렌더는 실제 돔에 반영할 변경 사항을 파악하는 단계이고, 커밋은 파악된 변경 사항을 실제 돔에 반영하는 단계이다.<br>
렌더 단계에서는 변경 사항을 파악하기 위해 가상돔을 이용한다.<br><br>
가상 돔은 리액트 요소로부터 만들어지는데, 리액트는 랜더링을 할 때 마다 가상돔을 만들고 이전의 가상 돔과 비교한다.<br>
이는 실제 돔의 변경 사항을 최소화 하기 위한 과정이다.
#### 실제 돔으로 만드는 과정을 보여 줄 예제 코드
```javascript
function Todo({ title, desc}) {
  const [priority, setPriority] = useState("high");
  function onClick() {
    setPriority(priority === "high" ? "low" : "high");
  }
  return (
    <div>
      <Title title={title} />
      <p>{desc}</p>
      <p>{priority === "high" ? "우선순위 높음" : "우선순위 낮음"}</p>
      <button onClick={onClick}>우선순위 변경</p>
    </div>
  );
}

const Title = React.memo(({title}) => {
  return <p style={{ color: "blue" }}>{title}</p>
});

ReactDOM.render(
  <Todo title="리액트 공부하기" desc="실전 리액트 프로그래밍을 열심히 읽는다." />,
  document.getElementById('root'),
);
```
Todo컴포넌트는 Title 컴포넌트를 자식으로 사용한다.<br>
버튼을 클릭하면 priority 상탯값이 변경되고 화면을 다시 그린다.<br>
React.memo로 만들어진 Title 컴포넌트는 속성값을 변경될 때만 호출한다.
#### ReactDOM.render 함수로 전달된 리액트 요소 트리의 구조
첫 번째로 만들어지는 리액트 요소
```javascript
const initialElementTree = {
  type: Todo,
  props: {
    title: '리액트 공부하기',
    desc: '실전 리액트 프로그래밍을 열심히 읽는다',
  }
};
```
Todo 컴포넌트의 렌더링 결과를 얻기 위해 Todo 컴포넌트 함수를 호출한다.
#### Todo 컴포넌트 함수 호출 결과
```javascript
const elementTree = {
  type: 'div',
  props: {
    children: [
      {
        type: Title,
        props: {title: '리액트 공부하기'},        
      },
      {
        type: 'p',
        props: { children: '실전 리액트 프로그래밍을 열심히 읽는다' },
      },
      {
        type: 'p',
        props: { children: '우선숲위 높음'},
      },
      {
        type: 'button',
        props: {
          onClick: function() {
            //Todo 컴포넌트의 onClick 함수
          },
          children: '우선순위 변경',
        }
      }
    ]
  }
}
```
트리의 루트는 DIV로 변경된다.<br>
Title 컴포넌트가 존재하기 때문에 이 트리를 실제 돔으로 만들 수 없다.<br>
리액트 요소 트리가 실제 돔으로 만들어지기 위해서는 모든 리액트 요소의 type 속성값이 문자열이어야 한다.<br>
이는 type 속성값이 문자열이어야 HTML태그로 변환할 수 있기 때문이다.<br>
그러기 위해서는 모든 컴포넌트 함수가 호출되어야 한다.
#### Title 컴포넌트 함수 호출 결과
```javascript
const elementTree = {
  type: 'div',
  props: {
    children: [
      {
        type: 'p',
        props: {
          style: { color: 'blue' },
          children: '리액트 공부하기',
        }
      {
        type: 'p',
        props: { children: '실전 리액트 프로그래밍을 열심히 읽는다' },
      },
      {
        type: 'p',
        props: { children: '우선숲위 높음'},
      },
      {
        type: 'button',
        props: {
          onClick: function() {
            //Todo 컴포넌트의 onClick 함수
          },
          children: '우선순위 변경',
        }
      }
    ]
  }
}
```
Title 컴포넌트 요소가 p태그로 변경됨에 따라 모든 리액트 요소의 type 속성값이 문자열이므로 실제 돔을 만들 수 있다.<br>
실제 돔을 만들 수 있는 리액트 요소 트리를 가상 돔이라고 한다. 최초의 리액트 요소 트리로부터 가상 돔을 만들고 이전 가상 돔과 비교해서 실제 돔에 반영할 내용을 결정하는 단계를 렌더라고 한다.<br>
리액트는 화면을 업데이트할 때 이전의 가상돔과 현재의 가상 돔을 비교해서 변경된 부분만 실제 돔에 반영한다. 브라우저에서 꼭 필요한 부분만 변경해주는게 중요한데 직접 하기 귀찮은 작업을 리액트가 알아서 해준다.<br>
렌더 단계는 ReactDOM.render 함수와 상탯값 변경 함수에 의해 시작된다.<br>
ReactDOM.render 함수에 의해 시작된 랜더 단계에서 이번엔 상태값 변경 함수에 의해 수행되는 렌더 단계를 알아본다.
#### setPriority 함수 호출 후 만들어진 리액트 요소 트리
```javascript
const elementTree = {
  type: 'div',
  props: {
    children: [
      {
        type: Title,
        props: { title: '리액트 공부하기'},
      },
      {
        type: 'p',
        props: {children: '실전 리액 }
      }
    ]
  }
}
```